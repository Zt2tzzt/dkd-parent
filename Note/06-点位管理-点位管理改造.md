# 点位管理之点位管理改造

## 一、搜索框改造

### 1.1.区域 id 改造

将搜索框中的区域 id，改为下拉列表的类型，并查询区域的列表，展示在前端。

查询区域列表的接口如下：

基本信息

Path： /manage/region/list

Method： GET

接口描述：

请求参数

Query

| 参数名称 | 是否必须 | 示例   | 备注     |
| -------- | -------- | ------ | -------- |
| pageNum  | 是       | 1      | 当前页   |
| pageSize | 是       | 10     | 每页个数 |
| name     | 否       | 海淀区 | 区域名称 |

返回数据

| 名称         | 类型      | 是否必须 | 默认值 | 备注     | 其他信息          |
| ------------ | --------- | -------- | ------ | -------- | ----------------- |
| total        | number    | 必须     |        |          | mock: 3           |
| rows         | object [] | 必须     |        |          | item 类型: object |
| ├─ remark    | string    | 必须     |        | 备注说明 |                   |
| ├─ id        | number    | 必须     |        | 区域ID   |                   |
| ├─ name      | string    | 必须     |        | 区域名称 |                   |
| ├─ nodeCount | number    | 必须     |        | 点位数量 |                   |
| code         | number    | 必须     |        |          | mock: 200         |
| msg          | string    | 必须     |        |          | mock: 查询成功    |

找到区域列表的 api 请求如下：

src/api/manage/region.js

```js
// 查询区域管理列表
export function listRegion(query) {
  return request({
    url: '/manage/region/list',
    method: 'get',
    params: query
  })
}
```

- 要修改传入其中的 `query` 参数。

将视图组件的“区域 id”改名为“区域搜索”，并将它的文本框类型，改为下拉框：

src/views/manage/node/index.vue

```vue
<el-form-item label="区域 ID" prop="regionId">
  <!-- <el-input
    v-model="queryParams.regionId"
    placeholder="请输入区域 ID"
    clearable
    @keyup.enter="handleQuery"
  /> -->
  <el-select v-model="queryParams.regionId" placeholder="请选择区域" clearable>
    <el-option
      v-for="item of regionOptions"
      :key="item.id"
      :label="item.name"
      :value="item.id"
    />
  </el-select>
</el-form-item>

……

<script>
import { listRegion } from '@/api/manage/region'

/** 查询区域列表 */
const regionOptions = ref([])
function getRegionList() {
  listRegion({ pageNum: 1, pageSize: 10000 }).then(res => {
    regionOptions.value = res.rows
  })
}

……

getRegionList()
</script>
```

- 传入 `{ pageNum: 1, pageSize: 10000 }` 用来查找区域列表。

## 二、添加或修改对话框改造

### 3.1.区域 Id 改造

将“区域 id”，改名为“所属区域”，并将它从文本框改为下拉列表。

src/views/manage/node/index.vue

```vue
<el-form-item label="所属区域" prop="regionId">
  <!-- <el-input v-model="form.regionId" placeholder="请输入区域 ID" /> -->
  <el-select v-model="form.regionId" placeholder="请选择所属区域" clearable>
    <el-option
      v-for="item of regionOptions"
      :key="item.id"
      :label="item.name"
      :value="item.id"
    />
  </el-select>
</el-form-item>
```

### 3.2.合作商 id 改造

将“合作商 id”，改名为“归属合作商“，并将它从文本框改为下拉框。

src/views/manage/node/index.vue

```vue
<template>
……

  <el-form-item label="归属合作商" prop="partnerId">
    <!-- <el-input v-model="form.partnerId" placeholder="请输入合作商 ID" /> -->
    <el-select v-model="form.partnerId" placeholder="请选择归属合作商" clearable>
      <el-option
        v-for="item in partnerOptions"
        :key="item.id"
        :label="item.name"
        :value="item.id"
      ></el-option>
    </el-select>
  </el-form-item>

……
</template>

<script>
import { listPartner } from '@/api/manage/partner';

/** 查询合作商列表 */
const partnerOptions = ref([])
function getPartnerList() {
  listPartner(loadAllParams).then(res => {
    partnerOptions.value = res.rows
  })
}

……

getPartnerList()
</script>
```

- `loadAllParams` 的值为 `{ pageNum: 1, pageSize: 10000 }`。

## 三、列表视图改造

### 3.1.加入序号列

src/views/manage/node/index.vue

```vue
<el-table-column label="序号" type="index" align="center" width="50" />
```

### 3.2.区域 id，合作商 id 改造

将“区域 id”，“合作商 id”列名称，改为“区域”，“合作商”。

并将它们的值，显示出来，而不是 id。

并查询点位下的所有设备。

导入准备好的 sql，里面有设备表等等共 39 张表，在系统后面的开发中会用到。

- isql/dkd.sql

#### 3.2.1.实现思路

使用**关联查询**和**关联实体**结合的方式：

- **关联查询**：对于设备数量的统计，我们需要执行关联查询（左连接），直接在 mapper 层封装。
- **关联实体**：对于区域、合作商的数据，我们采用 MyBatis 提供的嵌套查询功能。
  - 将原有的多表联合查询，拆分成单个表的查询。再利用 MyBatis 的语法，将它们嵌套在一起。

#### 3.2.2. `<resultMap>` 标签

通过在 XML 映射文件中，使用 `<resultMap>` 标签，完成映射；

- 它的子标签有 `<association>` 和 `<collection>`，可以完成实体的关联。

#### 3.2.3.`<association>` 标签

`<association>` 标签，用于解决一对一、多对一关系下，映射结果集只有一个对象时，完成 ORM 的结果映射封装。

- 比如：点位和区域，点位和合作商，都是多对一的关系。

#### 3.2.4.`<collection>` 标签

`<collection>` 标签，用来解决一对多关系下，映射多个结果的集合。

- 比如：查询单个区域表，同时查询区域下所有点位的信息。

> ORM（Object-Relational Mapping，对象关系映射）是一种技术，用于在面向对象编程语言（如 Python、Java、C#）中，将**对象模型**（类和对象）与**关系数据库**（表和行）进行映射，从而实现对象与数据库之间的数据交互。
>
> ORM 映射的关键概念：
>
> 1. **对象与表的映射**
>    - 每个类对应关系数据库中的一张表。
>    - 类的实例对应表中的一条记录。
> 2. **属性与列的映射**
>    - 类的属性对应表中的列。
>    - 属性类型对应列的数据类型（如 `String` 映射为 `VARCHAR`，`Integer` 映射为 `INT`）。
> 3. **方法与操作的映射**
>    - 类的方法（如 `save()`、`delete()`）对应数据库操作（如 `INSERT`、`DELETE` 等）。

总结：MyBatis 的嵌套查询，可以将复杂的多表查询，分解为简单，容易管理的单表查询；这么做：

- 简化了 sql 语句的编写，而且提高了查询效率。
- 避免内存溢出的风险，保证了代码的整洁和可维护性。

#### 3.2.5.SQL 准备

查询点位下，所有设备（`vending_machine` 表），编写 sql

Prompt 提示词工程输入：

```markdown
角色：你是一个软件工程师；
指示：根据表结构关系，编写 mysql 脚本。
上下文：如下有两张表的建表语句：
-- auto-generated definition
CREATE TABLE node
(
    id                     INT AUTO_INCREMENT COMMENT '主键 ID'
        PRIMARY KEY,
    name                   VARCHAR(100)                       NOT NULL COMMENT '点位名称',
    address                VARCHAR(255)                       NULL COMMENT '详细地址',
    business_district_type INT                                NULL COMMENT '商圈类型',
    region_id              INT                                NOT NULL COMMENT '区域 ID',
    partner_id             INT                                NOT NULL COMMENT '合作商 ID',
    create_time            DATETIME DEFAULT CURRENT_TIMESTAMP NULL COMMENT '创建时间',
    update_time            DATETIME DEFAULT CURRENT_TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    create_by              VARCHAR(50)                        NULL COMMENT '创建人',
    update_by              VARCHAR(50)                        NULL COMMENT '修改人',
    remark                 TEXT                               NULL COMMENT '备注',
    CONSTRAINT node_ibfk_1
        FOREIGN KEY (region_id) REFERENCES region (id)
            ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT node_ibfk_2
        FOREIGN KEY (partner_id) REFERENCES partner (id)
            ON UPDATE CASCADE ON DELETE CASCADE
)
    COMMENT '点位表' ROW_FORMAT = DYNAMIC;

CREATE INDEX partner_id
    ON node (partner_id);

CREATE INDEX region_id
    ON node (region_id);

-- auto-generated definition
CREATE TABLE vending_machine
(
    id                   BIGINT AUTO_INCREMENT COMMENT '主键'
        PRIMARY KEY,
    inner_code           VARCHAR(15) DEFAULT '000'                 NULL COMMENT '设备编号',
    channel_max_capacity INT                                       NULL COMMENT '设备容量',
    node_id              INT                                       NOT NULL COMMENT '点位Id',
    addr                 VARCHAR(100)                              NULL COMMENT '详细地址',
    last_supply_time     DATETIME    DEFAULT '2000-01-01 00:00:00' NOT NULL COMMENT '上次补货时间',
    business_type        INT                                       NOT NULL COMMENT '商圈类型',
    region_id            INT                                       NOT NULL COMMENT '区域Id',
    partner_id           INT                                       NOT NULL COMMENT '合作商Id',
    vm_type_id           INT         DEFAULT 0                     NOT NULL COMMENT '设备型号',
    vm_status            INT         DEFAULT 0                     NOT NULL COMMENT '设备状态，0:未投放;1-运营;3-撤机',
    running_status       VARCHAR(100)                              NULL COMMENT '运行状态',
    longitudes           DOUBLE      DEFAULT 0                     NULL COMMENT '经度',
    latitude             DOUBLE      DEFAULT 0                     NULL COMMENT '维度',
    client_id            VARCHAR(50)                               NULL COMMENT '客户端连接Id,做emq认证用',
    policy_id            BIGINT                                    NULL COMMENT '策略id',
    create_time          TIMESTAMP   DEFAULT CURRENT_TIMESTAMP     NOT NULL COMMENT '创建时间',
    update_time          TIMESTAMP   DEFAULT CURRENT_TIMESTAMP     NULL COMMENT '修改时间',
    CONSTRAINT vendingmachine_VmId_uindex
        UNIQUE (inner_code),
    CONSTRAINT vending_machine_ibfk_1
        FOREIGN KEY (vm_type_id) REFERENCES vm_type (id),
    CONSTRAINT vending_machine_ibfk_2
        FOREIGN KEY (node_id) REFERENCES node (id),
    CONSTRAINT vending_machine_ibfk_3
        FOREIGN KEY (policy_id) REFERENCES policy (policy_id)
)
    COMMENT '设备表';

CREATE INDEX policy_id
    ON vending_machine (policy_id);

CREATE INDEX vendingmachine_node_Id_fk
    ON vending_machine (node_id);

CREATE INDEX vendingmachine_vmtype_TypeId_fk
    ON vending_machine (vm_type_id);
输出：查询并显示点位表所有的字段信息，同时显示每个点位的设备数量。
```

输出：

```mysql
SELECT
    n.id,
    n.name,
    n.address,
    n.business_district_type,
    n.region_id,
    n.partner_id,
    n.create_time,
    n.update_time,
    n.create_by,
    n.update_by,
    n.remark,
    COUNT(vm.id) AS vm_count  -- 统计每个点位的设备数量
FROM
    node n
LEFT JOIN
    vending_machine vm ON n.id = vm.node_id  -- 连接设备表
GROUP BY
    n.id;  -- 按点位 ID 分组
```

再根据点位的区域外键 `region_id` 查询区域信息。

```mysql
SELECT * FROM region WHERE id = 1;
```

再根据点位的合作商外键 `partner_id` 查询合作商的信息。

```mysql
SELECT * FROM partner WHERE id = 1;
```

#### 3.2.6.VO 类准备

dkd-manage/src/main/java/com/dkd/manage/domain/vo/NodeVO.java

```java
package com.dkd.manage.domain.vo;

import com.dkd.manage.domain.Node;
import com.dkd.manage.domain.Partner;
import com.dkd.manage.domain.Region;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class NodeVO extends Node {
    // 设备数量
    private Integer vmCount;

    // 区域信息
    private Region region;

    // 合作商信息
    private Partner partner;
}
```

#### 3.2.7.Mapper 层改造

在 `NodeMapper` 接口中，加入 `selectNodeVOList` 方法。

dkd-manage/src/main/java/com/dkd/manage/mapper/NodeMapper.java

```java
/**
 * 此方法用于：查询点位管理列表
 *
 * @param node 点位
 * @return List<NodeVO>
 */
List<NodeVO> selectNodeVOList(Node node);
```

XML 映射文件

dkd-manage/src/main/resources/mapper/manage/NodeMapper.xml

```xml
<select id="selectNodeVOList" resultType="com.dkd.manage.domain.vo.NodeVO">
    SELECT n.id, n.name, n.address, n.business_district_type, n.region_id, n.partner_id, n.create_time,
    n.update_time, n.create_by, n.update_by, n.remark,
    COUNT(vm.id) AS vm_count -- 统计每个点位的设备数量
    FROM node n
    LEFT JOIN vending_machine vm ON n.id = vm.node_id -- 连接设备表
    <where>
        <if test="name != null  and name != ''">and n.name like concat('%', #{name}, '%')</if>
        <if test="regionId != null ">and n.region_id = #{regionId}</if>
        <if test="partnerId != null ">and n.partner_id = #{partnerId}</if>
    </where>
    GROUP BY n.id
</select>
```

目前 `<select>` 标签上，使用的是 `resultType` 属性，进行的结果集自动封装。

现在要改为 `resultMap` 属性，进行手动的封装，如下所示：

```xml
<select id="selectNodeVOList" resultMap="NodeVOResult">
    SELECT n.id, n.name, n.address, n.business_district_type, n.region_id, n.partner_id, n.create_time,
    n.update_time, n.create_by, n.update_by, n.remark,
    COUNT(vm.id) AS vm_count -- 统计每个点位的设备数量
    FROM node n
    LEFT JOIN vending_machine vm ON n.id = vm.node_id -- 连接设备表
    <where>
        <if test="name != null  and name != ''">and n.name like concat('%', #{name}, '%')</if>
        <if test="regionId != null ">and n.region_id = #{regionId}</if>
        <if test="partnerId != null ">and n.partner_id = #{partnerId}</if>
    </where>
    GROUP BY n.id
</select>
```

在 XML 映射文件中，自定义 `resultMap` 标签，用于映射查询结果：

dkd-manage/src/main/resources/mapper/manage/NodeMapper.xml

```xml
<resultMap id="NodeVOResult" type="NodeVO">
    <result property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="address" column="address"/>
    <result property="businessDistrictType" column="business_district_type"/>
    <result property="regionId" column="region_id"/>
    <result property="partnerId" column="partner_id"/>
    <result property="createTime" column="create_time"/>
    <result property="updateTime" column="update_time"/>
    <result property="createBy" column="create_by"/>
    <result property="updateBy" column="update_by"/>
    <result property="remark" column="remark"/>
    <result property="vmCount" column="vm_count"/>
    <association property="region" javaType="Region" column="region_id"
                 select="com.dkd.manage.mapper.RegionMapper.selectRegionById"/>
    <association property="partner" javaType="Partner" column="partner_id"
                 select="com.dkd.manage.mapper.PartnerMapper.selectPartnerById"/>
</resultMap>
```

`<association>` 标签的：

- `property` 属性，对应 `NodeVO` 类中的属性名；
- `javaType` 属性，对应该属性的 Java 实体类型。
- `column`  属性，表示查询的列名。
- `select` 属性，表示将查询的列的值，传入一个方法的全限定名，将 `column` 对应的值，传入该方法的型参中。

#### 3.2.8.Service 层改造

dkd-manage/src/main/java/com/dkd/manage/service/INodeService.java

```java
/**
 * 此方法用于：查询点位管理列表
 *
 * @param node 点位
 * @return List<NodeVO>
 */
List<NodeVO> nodeVOList(Node node);
```

dkd-manage/src/main/java/com/dkd/manage/service/impl/NodeServiceImpl.java

```java
/**
 * 此方法用于：查询点位管理列表
 *
 * @param node 点位
 * @return List<NodeVO>
 */
@Override
public List<NodeVO> nodeVOList(Node node) {
    return nodeMapper.selectNodeVOList(node);
}
```

#### 3.2.9.Controller 层改造

dkd-manage/src/main/java/com/dkd/manage/controller/NodeController.java

```java
/**
 * 查询点位管理列表
 */
@PreAuthorize("@ss.hasPermi('manage:node:list')")
@GetMapping("/list")
public TableDataInfo list(Node node)
{
    startPage();
    List<NodeVO> list = nodeService.nodeVOList(node);
    return getDataTable(list);
}
```

#### 3.2.10.前端改造

src/views/manage/node/index.vue

```vue
<el-table-column label="区域" align="center" prop="region.name" />
……
<el-table-column label="合作商" align="center" prop="partner.name" />
```

## 四、数据完整性

当删除区域或者合作商时，与它关联的点位，也会被删除。

这时因为数据库中的外键约束造成的：

```mysql
CONSTRAINT node_ibfk_1
    FOREIGN KEY (region_id) REFERENCES region (id)
        ON UPDATE CASCADE ON DELETE CASCADE,
CONSTRAINT node_ibfk_2
    FOREIGN KEY (partner_id) REFERENCES partner (id)
        ON UPDATE CASCADE ON DELETE CASCADE
```

将删除的操作改为 RESTRICT

```mysql
alter table node
    drop foreign key node_ibfk_1;

alter table node
    add constraint node_ibfk_1
        foreign key (region_id) references region (id)
            on update cascade;

alter table node
    drop foreign key node_ibfk_2;

alter table node
    add constraint node_ibfk_2
        foreign key (partner_id) references partner (id)
            on update cascade;
```

在全局异常处理类中，对 `java.sql.SQLIntegrityConstraintViolationException: Cannot delete or update a parent row:` 错误，进行处理：

> `SQLIntegrityConstraintViolationException` 类，通常用于表示数据库操作违反了完整性约束；
>
> - 比如：外键约束、唯一性约束
>
> `DataIntegrityViolationException` 类，在 Spring Boot 框架中，如果违反了数据完整性，则抛出这个异常。

在 dkd-framework 包下，定义了全局异常处理类 `GlobalExceptionHandler`，在其中添加方法 `handleDataIntegrityViolationException`

dkd-framework/src/main/java/com/dkd/framework/web/exception/GlobalExceptionHandler.java

```java
/**
 * 此方法用于：处理数据完整性异常
 */
@ExceptionHandler(DataIntegrityViolationException.class)
public AjaxResult handleDataIntegrityViolationException(DataIntegrityViolationException e) {
    log.error("数据完整性异常", e);

    if (e.getMessage().contains("foreign key"))
        return AjaxResult.error("无法删除，有其它数据引用");

    return AjaxResult.error("数据完整性异常，请检查数据是否完整");
}
```

# 工单管理之新增工单

需求：本系统中有两类工单需要创建，分别是：

- **运维工单**：主要是对售货机的操作，又可以细分为投放工单、维修工单、撤机工单、
- **运营工单**：主要是对货物的操作，只有一种就是补货工单。

新增工单时序图：

![新增工单时序图](/Users/zetian/workshop/project/dkd-parent/Note/NodeAssets/新增工单时序图.png)

## 一、接口文档

基本信息

**Path：** /manage/task

**Method：** POST

请求参数：

Headers

| 参数名称     | 参数值           | 是否必须 | 示例 | 备注 |
| ------------ | ---------------- | -------- | ---- | ---- |
| Content-Type | application/json | 是       |      |      |

Body

| 名称              | 类型      | 是否必须 | 默认值 | 备注                                                   | 其他信息          |
| ----------------- | --------- | -------- | ------ | ------------------------------------------------------ | ----------------- |
| createType        | number    | 必须     |        | 创建类型，传1                                          |                   |
| innerCode         | string    | 必须     |        | 设备编号                                               |                   |
| userId            | number    | 必须     |        | 执行人Id                                               |                   |
| assignorId        | number    | 非必须   |        | 指派人Id                                               |                   |
| productTypeId     | number    | 必须     |        | 工单类型Id 1,投放工单 2,补货工单 3,维修工单 4,撤机工单 |                   |
| desc              | string    | 必须     |        | 描述信息                                               |                   |
| details           | object [] | 非必须   |        | 补货信息(补货工单才有)                                 | item 类型: object |
| ├─ channelCode    | string    | 非必须   |        | 货道编号                                               |                   |
| ├─ expectCapacity | number    | 非必须   |        | 补货数量                                               |                   |
| ├─ skuId          | number    | 非必须   |        | 商品Id                                                 |                   |
| ├─ skuName        | string    | 非必须   |        | 商品名称                                               |                   |
| ├─ skuImage       | string    | 非必须   |        | 商品图片                                               |                   |

返回数据

| 名称 | 类型   | 是否必须 | 默认值 | 备注 | 其他信息 |
| ---- | ------ | -------- | ------ | ---- | -------- |
| msg  | string | 必须     |        |      |          |
| code | number | 必须     |        |      |          |

## 二、DTO 类设计

因为没有现成的用于接收前端请求参数的类，所以自行设计 DTO 类。

`TaskDetailDTO` 类设计

dkd-manage/src/main/java/com/dkd/manage/domain/vo/TaskDetailDTO.java

```java
package com.dkd.manage.domain.vo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class TaskDetailDTO {
    private String channelCode;// 货道编号
    private Long expectCapacity;// 补货数量
    private Long skuld;// 商品id
    private String skuName;// 商品名称
    private String skuImage;// 商品图片
}
```

`TaskDTO` 类设计

dkd-manage/src/main/java/com/dkd/manage/domain/vo/TaskDTO.java

```java
package com.dkd.manage.domain.vo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class TaskDTO {
    private Long createType;// 创建类型
    private String innerCode;// 设备编号
    private Long userId;// 执行人id
    private Long assignorId;// 指派人id
    private Long productTypeId;// 工单类型
    private String desc;// 描述信息
    private List<TaskDetailDTO> details;// 工单详情（只有补货工单才涉及）
}
```

## 三、TaskDetails Mapper 层改造

使用 AIGC 学习单条记录新增的 xml 语句，生成批量新增的 xml 语句。

`TaskDetailsMapper` xml 映射文件

dkd-manage/src/main/resources/mapper/manage/TaskDetailsMapper.xml

```xml
<insert id="insertTaskDetailsBatch" parameterType="java.util.List" useGeneratedKeys="true" keyProperty="detailsId">
    insert into task_details (task_id, channel_code, expect_capacity, sku_id, sku_name, sku_image)
    values
    <foreach collection="list" item="item" separator=",">
        (#{item.taskId}, #{item.channelCode}, #{item.expectCapacity}, #{item.skuId}, #{item.skuName},
        #{item.skuImage})
    </foreach>
</insert>
```

`TaskDetailsMapper` 接口

dkd-manage/src/main/java/com/dkd/manage/mapper/TaskDetailsMapper.java

```java
/**
 * 此方法用于：批量新增工单详情
 *
 * @param taskDetailsList 工单详情集合
 * @return int
 */
int insertTaskDetailsBatch(List<TaskDetails> taskDetailsList);
```

> 不同模块之间的业务调用，应该是 Service 层之间的调用；
>
> - 这样能更好的实现业务解耦，提高可维护性；在业务层中还可以控制事务的传播行为。
>
> 当然，如果业务简单，直接调用 Mapper 层也是没问题的。

## 四、TaskDetails Service 层改造

`ITaskService` 接口

dkd-manage/src/main/java/com/dkd/manage/service/ITaskService.java

```java
/**
 * 此方法用于：批量新增工单
 * @param tasks 工单集合
 * @return int
 */
int insertTasksBatch(List<Task> tasks);
```

`TaskServiceImpl` 实现类

dkd-manage/src/main/java/com/dkd/manage/service/impl/TaskServiceImpl.java

```java
/**
 * 此方法用于：批量新增工单
 *
 * @param tasks 工单列表
 * @return int
 */
@Override
public int insertTasksBatch(List<Task> tasks) {
    return taskMapper.insertTasksBatch(tasks);
}
```

新增工单的流程如下：

1. ﻿﻿﻿查询售货机是否存在；
2. ﻿﻿校验售货机状态与工单类型是否相符；
3. ﻿﻿﻿检查设备是否有未完成的同类型工单；
4. ﻿﻿﻿查询并校验员工是否存在；
5. ﻿﻿校验员工所属区域是否匹配；
6. `TaskDTO` 转为 `Task` 并补充属性，保存工单；
7. 判断是否为补货工单；
8. `TaskDetailsDTO` 转为 `TaskDetails` 并补充属性，批量保存。
   - 使用 Stream 流。

![新增工单流程图](/Users/zetian/workshop/project/dkd-parent/Note/NodeAssets/新增工单流程图.png)

## 五、Task Service 层改造

`ITaskService` 接口

dkd-manage/src/main/java/com/dkd/manage/service/ITaskService.java

```java
/**
 * 此方法用于：新增工单
 * @param taskDTO 工单
 * @return int
 */
int insertTaskDTO(TaskDTO taskDTO);
```

`TaskServiceImpl`. 实现类

dkd-manage/src/main/java/com/dkd/manage/service/impl/TaskServiceImpl.java

```java
/**
 * 此方法用于，校验售货机状态与工单类型是否相符
 *
 * @param vmStatus      设备状态
 * @param productTypeId 工单类型
 */
private void checkCreateTask(Long vmStatus, Long productTypeId) {
    // 如果是投放工单，设备在运行中，抛出异常
    if (DkdContants.TASK_TYPE_DEPLOY.equals(productTypeId) && DkdContants.VM_STATUS_RUNNING.equals(vmStatus))
        throw new ServiceException("设备正在运行中，无法进行投放工单");
    // 如果是维修工单，设备不在运行中，抛出异常
    if (DkdContants.TASK_TYPE_REPAIR.equals(productTypeId) && !DkdContants.VM_STATUS_RUNNING.equals(vmStatus))
        throw new ServiceException("设备不在运行中，无法进行维修工单");
    // 如果是补货工单，设备不在运行中，抛出异常
    if (DkdContants.TASK_TYPE_SUPPLY.equals(productTypeId) && !DkdContants.VM_STATUS_RUNNING.equals(vmStatus))
        throw new ServiceException("设备不在运行中，无法进行补货工单");
    // 如果是撤机工单，设备不在运行中，抛出异常
    if (DkdContants.TASK_TYPE_REVOKE.equals(productTypeId) && !DkdContants.VM_STATUS_RUNNING.equals(vmStatus))
        throw new ServiceException("设备不在运行中，无法进行撤机工单");
}

/**
 * 此方法用于：检查设备是否有未完成的同类型工单
 *
 * @param taskDTO 工单详情
 */
private void hasTask(TaskDTO taskDTO) {
    Task taskParam = new Task();
    taskParam.setInnerCode(taskDTO.getInnerCode());
    taskParam.setProductTypeId(taskDTO.getProductTypeId());
    taskParam.setTaskStatus(DkdContants.TASK_STATUS_PROGRESS);
    List<Task> tasks = taskMapper.selectTaskList(taskParam);
    if (tasks != null && !tasks.isEmpty())
        throw new ServiceException("设备存在未完成的工单");
}

/**
 * 此方法用于：生成工单编号
 *
 * @return 工单编号
 */
private String generateTaskCode() {
    // 获取当前日期，并格式化为 yyyyMMdd
    String dateStr = DateUtils.getDate().replace("-", "");

    // 根据日期，生成当前日期的 key，用于 Redis 中的自增。
    String key = "dkd.task.code" + dateStr;

    // 判断 key 是否存在
    if (!redisTemplate.hasKey(key)) {
        redisTemplate.opsForValue().set(key, 1, Duration.ofDays(1)); // 设置初始值 1，并设置过期时间为 1 天
        return dateStr + "0001";
    }
    Long value = redisTemplate.opsForValue().increment(key);
    return dateStr + String.format("%04d", value);
}

/**
 * 此方法用于：批量新增工单详情
 *
 * @param taskDTO 工单详情
 * @return int
 */
@Transactional(rollbackFor = Exception.class)
@Override
public int insertTaskDTO(TaskDTO taskDTO) {
    // 查询售货机是否存在
    VendingMachine vm = vendingMachineService.selectVendingMachineByInnerCode(taskDTO.getInnerCode());
    if (vm == null)
        throw new ServiceException("售货机不存在");

    // 校验售货机状态与工单类型是否相符
    checkCreateTask(vm.getVmStatus(), taskDTO.getProductTypeId());

    // 检查设备是否有未完成的同类型工单
    hasTask(taskDTO);

    // 判断员工是否存在
    Emp emp = empService.selectEmpById(taskDTO.getUserId());
    if (emp == null)
        throw new ServiceException("员工不存在");

    // 校验员工地区是否匹配
    if (!emp.getRegionId().equals(vm.getRegionId()))
        throw new ServiceException("员工地区与售货机地区不匹配");

    // 将 DTO 转为 PO，并补充属性，保存工单
    Task task = BeanUtil.copyProperties(taskDTO, Task.class); // 将 taskDTO 中的 6 个属性复制到 task 上
    task.setTaskStatus(DkdContants.TASK_STATUS_CREATE); // 创建工单
    task.setUserName(emp.getUserName());
    task.setRegionId(vm.getRegionId());
    task.setAddr(vm.getAddr());
    task.setCreateTime(DateUtils.getNowDate());
    task.setTaskCode(generateTaskCode());
    int taskResult = taskMapper.insertTask(task);

    // 判断是否为补货工单
    if (DkdContants.TASK_TYPE_SUPPLY.equals(taskDTO.getProductTypeId())) {
        // 补货工单，需要批量新增工单详情
        List<TaskDetailDTO> detailDTOs = taskDTO.getDetails();
        if (detailDTOs == null || detailDTOs.isEmpty())
            throw new ServiceException("补货工单详情不能为空");
 
        List<TaskDetails> taskDetais = detailDTOs.stream()
                .map(dto -> {
                    TaskDetails taskDetails = BeanUtil.copyProperties(dto, TaskDetails.class);
                    taskDetails.setTaskId(task.getTaskId());
                    return taskDetails;
                })
                .collect(Collectors.toList());
        taskDetailsService.inserTaskDetailsBatch(taskDetais);
    }

    return taskResult;
}
```

- Java 中，所有包装类，都要使用 `equals` 方法进行相等判断。

### 5.1.Redis 自增命令的使用

Redis 的自增命令：`incr key`；每次执行该命令，key 都会自增 `1`；比如：

```sh
incr taskCode
```

## 六、Task Controller 层改造

`TaskController` 控制器类

dkd-manage/src/main/java/com/dkd/manage/controller/TaskController.java

```java
/**
 * 新增工单
 */
@PreAuthorize("@ss.hasPermi('manage:task:add')")
@Log(title = "工单", businessType = BusinessType.INSERT)
@PostMapping
public AjaxResult add(@RequestBody TaskDTO taskDTO) {
    // 设置指派人 id
    taskDTO.setAssignorId(getUserId());
    return toAjax(taskService.insertTaskDTO(taskDTO));
}
```

- `BaseController` 中有 `getUserId`、`getUserName`、`getLoginUser` 等方法，用于获取当前用户的信息。

